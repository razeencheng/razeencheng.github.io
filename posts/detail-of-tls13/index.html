<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><meta itemprop=name content="TLS 1.3 详解 (RFC 8446解读)"><meta itemprop=description content="10 Aug 2018 by Nick Sullivan.
在过去的五年中，IETF（Internet Engineering Task Force，定义互联网协议的标准机构）一直致力于标准化其最重要的安全协议之一，TLS协议的最新版本。TLS用于保护Web（远不止Web），提供加密并确保每个HTTPS网站和API的真实性。"><meta itemprop=datePublished content="2018-08-20T23:32:52+00:00"><meta itemprop=dateModified content="2018-08-20T23:32:52+00:00"><meta itemprop=wordCount content="8680"><meta itemprop=image content="https://razeencheng.com/android-chrome-192x192.png"><meta itemprop=keywords content="加密,tls1.3,https,"><meta property="og:title" content="TLS 1.3 详解 (RFC 8446解读)"><meta property="og:description" content="10 Aug 2018 by Nick Sullivan.
在过去的五年中，IETF（Internet Engineering Task Force，定义互联网协议的标准机构）一直致力于标准化其最重要的安全协议之一，TLS协议的最新版本。TLS用于保护Web（远不止Web），提供加密并确保每个HTTPS网站和API的真实性。"><meta property="og:type" content="article"><meta property="og:url" content="https://razeencheng.com/posts/detail-of-tls13/"><meta property="og:image" content="https://razeencheng.com/android-chrome-192x192.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-08-20T23:32:52+00:00"><meta property="article:modified_time" content="2018-08-20T23:32:52+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://razeencheng.com/android-chrome-192x192.png"><meta name=twitter:title content="TLS 1.3 详解 (RFC 8446解读)"><meta name=twitter:description content="10 Aug 2018 by Nick Sullivan.
在过去的五年中，IETF（Internet Engineering Task Force，定义互联网协议的标准机构）一直致力于标准化其最重要的安全协议之一，TLS协议的最新版本。TLS用于保护Web（远不止Web），提供加密并确保每个HTTPS网站和API的真实性。"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon href=/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=mask-icon href=/safari-pinned-tab.svg><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><link rel="shortcut icon" href=/favicon.ico><title>TLS 1.3 详解 (RFC 8446解读)</title><link rel=stylesheet href=https://razeencheng.com/css/style.min.a88782436067f84711b02510e9f09bd68bd49c25cd2e03624cd7320fa893b6ea.css integrity="sha256-qIeCQ2Bn+EcRsCUQ6fCb1ovUnCXNLgNiTNcyD6iTtuo=" crossorigin=anonymous></head><body id=page><header id=site-header><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://razeencheng.com>Razeen`s Blog</a></div><nav class="site-nav hide-in-mobile"><a href=https://razeencheng.com/posts/>文章</a>
<a href=https://razeencheng.com/tags/>标签</a>
<a href=https://razeencheng.com/categories/>分类</a>
<a href=https://razeencheng.com/about/>关于</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-social hide-in-mobile"><a href=https://twitter.com/razeencheng target=_blank rel="noopener me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://github.com/razeencheng target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></span><button id=menu-btn class=hdr-btn title=菜单><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://razeencheng.com/posts/>文章</a></li><li><a href=https://razeencheng.com/tags/>标签</a></li><li><a href=https://razeencheng.com/categories/>分类</a></li><li><a href=https://razeencheng.com/about/>关于</a></li></ul></div><main class="site-main section-inner"><article class=thin><header class=post-header><div class=post-meta><span>Aug 20, 2018</span></div><h1>TLS 1.3 详解 (RFC 8446解读)</h1></header><div class=content><p>10 Aug 2018 by <a href=https://blog.cloudflare.com/author/nick-sullivan/>Nick Sullivan</a>.</p><p>在过去的五年中，IETF（Internet Engineering Task Force，定义互联网协议的标准机构）一直致力于标准化其最重要的安全协议之一，TLS协议的最新版本。TLS用于保护Web（远不止Web），提供加密并确保每个HTTPS网站和API的真实性。</p><p>就在2018年8月10号，TLS协议的最新版本，TLS 1.3（<a href=https://www.rfc-editor.org/rfc/pdfrfc/rfc8446.txt.pdf>RFC 8446</a>）发布了。这是TLS协议的第一次重大改革，带来了重大的安全性和性能改进。本文深入探讨了TLS 1.3的重要变化及其对互联网安全未来的影响。</p><h3 id=tls协议的进化>TLS协议的进化<a href=#tls协议的进化 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>Cloudflare提供安全性的一个主要方式是支持网站和API等Web服务启用HTTPS。使用HTTPS（“S”代表安全），浏览器和服务器之间的消息通过加密和已经过身份验证的通道传输。网站通过HTTPS替代HTTP访问，能让用户确信自己访问的内容是网站所提供的原本内容， 并且确信通信是安全的，不会被窃听。互联网发展到今天，在线隐私问题变得更加重要，而这也是如今一个很大的问题。</p><p>HTTPS的能保证安全主要依赖的是TLS协议。TLS协议源于九十年代中期，Netscape开发的SSL的协议。到20世纪90年代末，Netscape将SSL交给IETF，IETF将其重命名为TLS，并从此成为该协议的管理者。许多人仍将Web加密称为SSL，即使绝大多数服务已切换到且仅支持TLS。SSL这个术语仍然受到人们的欢迎，Cloudflare的<a href=https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/>Keyless SSL</a>和<a href=https://blog.cloudflare.com/introducing-universal-ssl/>Universal SSL</a>等产品也仍然使用这重说法。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image5.png alt></p><p>在IETF中，协议称为RFC。TLS 1.0是RFC 2246，TLS 1.1是RFC 4346，TLS 1.2是RFC 5246.今天，TLS 1.3发布为RFC 8446. RFC通常按顺序发布，保留46作为RFC编号的一部分是一个很好的传承。</p><h3 id=tls-12已经成为过去>TLS 1.2已经成为过去<a href=#tls-12已经成为过去 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p><img src=https://s.razeen.cn/images/2018/tls13-image11.jpg alt></p><p>*<em><a href=https://memegenerator.net/Mc-Hammer-Pants>与Ham</a>一样，<a href=https://memegenerator.net/Mc-Hammer-Pants>MC Hammer</a>在90年代很受欢迎</em></p><p>在过去几年中，TLS已经出现了相当多的问题。首先，实现TLS的代码存在问题，包括<a href=https://blog.cloudflare.com/answering-the-critical-question-can-you-get-private-ssl-keys-using-heartbleed/>Heartbleed</a>，<a href=https://www.imperialviolet.org/2014/09/26/pkcs1.html>BERserk</a>，<a href=https://gotofail.com/>goto fail</a> 等等。这些问题还不是协议的基础问题，其主要是由于缺乏测试。像<a href=https://github.com/RUB-NDS/TLS-Attacker>TLS Attacker</a>和<a href=https://security.googleblog.com/2016/12/project-wycheproof.html>Project Wycheproof</a>这样的工具有助于提高TLS实施的稳健性，但TLS面临的更具挑战性的问题与协议本身有关。</p><p>TLS由工程师使用数学家的工具设计。SSL时代的许多早期设计决策都是使用最原始的方法，当时人们对如何设计健壮的安全协议不完全理解。也就是说，这不是协议设计者（Paul Kocher，Phil Karlton，Alan Freier，Tim Dierks，Christopher Allen等人）的错，因为整个行业都还在在学习如何正确地做到这一点。在设计TLS时，关于安全认证协议设计的正式论文还需要几年才发布（如Hugo Krawczyk的标志性<a href=http://webee.technion.ac.il/~hugo/sigma-pdf.pdf>SIGMA</a>论文）。TLS是90年代的加密方式：它当时意味着很好，看起来很酷，但是现代密码学已经发展的更加强壮了。</p><p>许多设计缺陷是使用<a href=https://en.wikipedia.org/wiki/Formal_verification>形式验证(Formal Verification)</a>发现的。学者们试图证明TLS的某些安全属性，但却找到了反例，这些反例被转化为真正的漏洞。这些弱点包括纯理论漏洞（<a href=https://access.redhat.com/articles/2112261>SLOTH</a>和<a href=https://eprint.iacr.org/2018/298.pdf>CurveSwap</a>），高资源攻击者漏洞（<a href=https://weakdh.org/imperfect-forward-secrecy-ccs15.pdf>WeakDH</a>，<a href=https://blog.cloudflare.com/logjam-the-latest-tls-vulnerability-explained/>LogJam</a>，<a href=https://censys.io/blog/freak>FREAK</a>，<a href=https://nakedsecurity.sophos.com/2016/08/25/anatomy-of-a-cryptographic-collision-the-sweet32-attack/>SWEET32</a>），实用和危险漏洞（<a href=https://en.wikipedia.org/wiki/POODLE>POODLE</a>，<a href=https://robotattack.org/>ROBOT</a>）。</p><h3 id=tls-12很慢>TLS 1.2很慢<a href=#tls-12很慢 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>互联网上，加密一直很重要。但从历史上看，只有登陆信息与信用卡信息被加密，使大多数其他数据暴露。在过去几年中，一直存在一个主要趋势，全面启用HTTPS。所有流量都经过HTTPS后，能使我们免受窃听者和<a href=https://blog.cloudflare.com/an-introduction-to-javascript-based-ddos/>注入攻击</a>的影响，但连接的速度却相对较慢。</p><p>要使浏览器和Web服务器就密钥达成一致，他们需要交换加密数据。自TLS于1999年标准化以来，在TLS中握手过程中的数据交换基本保持不变。握手需要在发送加密数据之前在浏览器和服务器之间再进行两次往返（或者在会话恢复先前连接时进行一次往返）。与单独的HTTP相比，HTTPS的TLS握手的额外成本导致潜在的问题。这种额外的延迟会对以性能为中心的应用产生负面影响。</p><h3 id=定义tls-13>定义TLS 1.3<a href=#定义tls-13 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>IETF对TLS 1.2的过时设计和两次往返开销不满意，开始着手定义新版本的TLS。2013年8月，Eric Rescorla为新协议制定了一份功能愿望清单：<a href=https://www.ietf.org/proceedings/87/slides/slides-87-tls-5.pdf>https</a>：
<a href=https://www.ietf.org/proceedings/87/slides/slides-87-tls-5.pdf>//www.ietf.org/proceedings/87/slides/slides-87-tls-5.pdf</a></p><p>经过<a href=https://www.ietf.org/mail-archive/web/tls/current/msg20938.html>一番辩论后</a>，决定将这个新版本的TLS称为TLS 1.3。推动TLS 1.3设计的主要问题与五年前提出的主要问题大致相同：</p><ul><li>减少握手延迟</li><li>加密更多的握手消息</li><li>提高跨协议攻击的难度</li><li>删除旧功能</li></ul><p>该规范由志愿者通过开放的设计过程设计，经过四年的勤奋工作和激烈的讨论，TLS 1.3现在处于最终形式：RFC 8446。随着协议的推广使用，新协议将使互联网更快，更多安全。</p><p>在这篇博文中，我将重点介绍TLS 1.3与以前版本相比的两个主要优势：安全性和性能。</p><h3 id=一些修复>一些修复<a href=#一些修复 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p><img src=https://s.razeen.cn/images/2018/tls13-image10.jpg alt></p><p>在过去的二十年中，我们已经学到了很多关于如何编写一个安全加密协议的相关知识。从POODLE到Lucky13到SLOTH到LogJam等一系列巧妙命名攻击表明，即使是TLS 1.2也包含了早期加密设计的一些陈旧观点。TLS 1.3的设计目标之一是通过消除潜在危险的设计元素来纠正以前的错误。</p><h4 id=修复密钥交换>修复密钥交换<a href=#修复密钥交换 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>TLS是所谓的“混合”密码系统。这意味着它同时使用对称密钥加密（加密和解密密钥相同）和公钥加密（加密和解密密钥不同）。混合方案是现互联网上使用的主要加密形式，如<a href=https://en.wikipedia.org/wiki/Secure_Shell>SSH</a>，<a href=https://en.wikipedia.org/wiki/IPsec>IPsec</a>，<a href=https://en.wikipedia.org/wiki/Signal_Protocol>Signal</a>，<a href=https://www.wireguard.com/>WireGuard</a>等其他协议。在混合密码系统中，公钥密码技术用于在双方之间建立共享密钥，共享密钥用于创建加密交换数据的对称密钥。</p><p>实际上，公钥加密是缓慢而且代价较高的（每个操作需要几微秒到几毫秒），对称密钥加密快速且代价小（每个操作都是纳秒级别）。混合加密方案允许您通过仅执行一次公钥加密，以极少的开销发送大量加密数据。TLS 1.3中的大部分工作都是关于改进握手部分，其中公钥用于建立对称密钥。</p><h4 id=rsa密钥交换>RSA密钥交换<a href=#rsa密钥交换 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>TLS中公钥是用来建立共享秘密的。使用公钥加密有两种主要方法。其中一种简单的方法是使用公钥加密：一方用另一方的公钥加密共享密钥并发送它。然后另一方使用其私钥解密共享秘密。最后他们生成相同的加密密钥。这种技术于1977年由Rivest，Shamir和Adelman发现，称为RSA密钥交换。在RSA密钥交换中，共享密钥由客户端生成，然后客户端利用服务器的公钥（从证书中提取）将共享密钥加密并将其发送到服务器。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image4.png alt></p><p>TLS中提供的另一种密钥交换形式是基于另一种形式的公钥密码技术，由Diffie和Hellman于1976年发明，即所谓的Diffie-Hellman密钥交换。在Diffie-Hellman中，客户端和服务器都从创建DH参数对开始。然后，他们将其DH参数的公共部分发送给另一方。当双方都收到对方方的公共参数时，它们将它与自己的私钥组合在一起，最终计算出同一个值：前主密钥。然后，服务器使用数字签名来确保交换未被篡改。如果客户端和服务器都为每次密钥交换选择一个新的DH参数，则该密钥交换称为“Ephemeral”（DHE）。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image3.png alt></p><p>两种模式都会使客户端和服务器具有共享密钥，但RSA模式有一个严重的缺点：它不是<a href=https://blog.cloudflare.com/staying-on-top-of-tls-attacks/>前向保密的</a>。这意味着如果有人记录加密的对话，然后获得了服务器的RSA私钥，他们就可以解密对话。这甚至适用于记录对话，在之后的一段时间内获取私钥的情况。如果一个国家政府正在记录这些加密内容，然后使用<a href=https://en.wikipedia.org/wiki/Heartbleed>Heartbleed</a>这样的漏洞来窃取用户私钥，这将是一个非常现实而且非常恐怖的事情。</p><p>RSA密钥交换在一段时间内一直存在问题，其原因不仅仅是因为它支持前向保密。而是因为想要正确的实现RSA密钥交换也是不容易的。1998年，Daniel Bleichenbacher在SSL中使用RSA加密时发现了一个漏洞并创建了所谓的“百万消息攻击”， 它允许攻击者通过发送数百万条消息或一些特定的消息给服务器，根据服务器响应的不同错误码计算加密密钥， 进而解密消息。多年来，这种攻击得到了改进，在某些情况下只需要数千次就可破解，这使得在笔记本电脑上都可以破解。最近发现，许多大型网站（包括facebook.com）在2017年也受到Bleichenbacher变种漏洞的影响，即<a href=https://robotattack.org/>ROBOT攻击</a>。</p><p>为了降低非前向加密连接和Bleichenbacher漏洞所带来的风险，RSA加密已从TLS 1.3中删除，将Diffie-Hellman Ephemeral作为唯一的密钥交换机制。在下面的性能部分中我们将讨论删除RSA密钥交换带来的其他优势。</p><h4 id=以diffie-hellman命名的加密手段>以Diffie-Hellman命名的加密手段<a href=#以diffie-hellman命名的加密手段 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>在加密方面，提供太多选项反而会导致选择错误。在选择DH参数时，这个原理最为明显。在以前版本的TLS中，DH参数的选择取决于参与者。这导致在一些算法实现中参数选择不正确，导致最后部署易受攻击。于是TLS 1.3取消了这一选择。</p><p>DH是一个功能强大的工具，但并非所有DH参数都可以“安全”使用。DH的安全性取决于称为数学中<a href=https://en.wikipedia.org/wiki/Discrete_logarithm>离散对数问题</a>的难度。如果可以解决一组参数的离散对数问题，就可以提取私钥并破坏协议的安全性。一般来说，使用的数字越大，解决离散对数问题就越困难。因此，如果您选择较小的DH参数，就有可能遭受攻击。</p><p>2015年的LogJam和WeakDH攻击表明，许多TLS服务器可能被欺骗使用较小的DH的参数，允许攻击者破坏协议并解密对话。</p><p>DH参数还需要具有某些其他数学属性。2016年，Antonio Sanso <a href=http://arstechnica.com/security/2016/01/high-severity-bug-in-openssl-allows-attackers-to-decrypt-https-traffic/>在OpenSSL中发现了一个漏洞</a>，该漏洞正是由于选择的参数缺乏正确的数学属性导致的。</p><p>TLS 1.3采用固定路由，将DH参数限制为已知安全的参数。但仍然保留了个选择，如果只允许一个选择，一旦以后发现这些参数不安全的，更新TLS将变得很困难。</p><h3 id=修复密码>修复密码<a href=#修复密码 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>混合加密方案的另外一部分是数据加密。数据加密主要通过一个对称算法以及双方协商出的会话密钥来完成的。下面我将告诉你，即时有很多算法可以完成数据的加密，但很多是不正确的。</p><h4 id=cbc模式密码>CBC模式密码<a href=#cbc模式密码 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>在上一节中，我们将TLS描述为混合加密方案，具有公钥和对称密钥两部分。公钥部分并不是多年来造成麻烦的唯一部分。对称加密部分也存在安全问题。在任何安全通信方案中，您都需要保证数据加密和数据的完整性（以确保人们不会修改，添加或删除对话内容）。对称密钥加密数据可用于提供数据的加密和数据的完整性，但在TLS 1.2及更早版本中，这两个部分以错误的方式组合，导致安全漏洞。</p><p>执行对称加密和解密的算法称为对称密码。对称密码通常有两种主要形式：分组密码和流密码。</p><p>流密码采用固定大小的密钥并使用它来创建任意长度的伪随机数据流，称为密钥流。要使用流密码进行加密，需要将密钥流的每个位与消息的相应位进行异或。要解密，需要使用密钥流对加密消息进行异或。纯流密码示例如RC4和ChaCha20。流密码很受欢迎，因为它们易于实现且计算速度快。</p><p>分组密码与流密码不同，因为它只加密固定大小的消息。如果要加密比块大小更短或更长的消息，则必须执行一些额外操作。对于较短的消息，必须在消息的末尾添加一些额外的数据。对于较长的消息，可以将消息拆分为密码可以加密的块，然后使用分组密码模式将各个部分以某种方式组合在一起。或者，可以通过使用块密码加密计数器序列将快密码装换成流密码。这称为“计数器模式”。使用分组密码加密任意长度数据的一种流行模式称为密码块链接（CBC）模式。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image9.png alt></p><p><img src=https://s.razeen.cn/images/2018/tls13-image7.png alt></p><p>为了防止人们篡改数据，加密是不够的，还需要保护数据的完整性。对于CBC模式密码，这是使用消息验证代码（MAC）来完成的。密码强度高的MAC具有以下特性：除非你知道密钥，否则找到与输入匹配的MAC值几乎是不可能的。有两种方法可以组合MAC和CBC模式密码。先加密，然后MAC密文，或者首先MAC明文，然后加密整个文件。在TLS中，他们选择后者，MAC-then-Encrypt，结果证明是错误的选择。</p><p>你可以理解为这个选择导致了<a href="https://www.youtube.com/watch?v=-_8-2pDFvmg">BEAST漏洞</a>，以及一系列填充oracle漏洞，例如<a href=http://www.isg.rhul.ac.uk/tls/Lucky13.html>Lucky 13</a>和<a href=https://eprint.iacr.org/2015/1129>Lucky Microseconds</a>。阅读我<a href=https://blog.cloudflare.com/padding-oracles-and-the-decline-of-cbc-mode-ciphersuites/>之前关于这个主题的帖子</a>，这里有全面的解释。CBC模式与填充之间的相互影响也是导致SSLv3或一些TLS中广泛流传的<a href=https://blog.cloudflare.com/sslv3-support-disabled-by-default-due-to-vulnerability/>POODLE漏洞</a>的原因。</p><p>RC4是Ron Rivest（RSA的“R”）设计的经典流密码，自TLS早期就获得广泛支持。在2013年，它被发现具有<a href=http://www.isg.rhul.ac.uk/tls/>可衡量的偏差</a>，攻击者可以利用它来解密消息。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image2.png alt=AEAD模式></p><p><em>AEAD模式</em></p><p>在TLS 1.3中，已删除所有有威胁的密码和密码模式。您不能再使用CBC模式密码或不安全的流密码，如RC4。TLS 1.3中允许的唯一类型的对称加密是一种称为<a href=https://blog.cloudflare.com/it-takes-two-to-chacha-poly/>AEAD（带有附加数据的经过身份验证的加密）</a>的新结构，它将数据加密以及数据的完整性无缝结合。</p><h3 id=修复数字签名>修复数字签名<a href=#修复数字签名 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>TLS的另一个重要作用是身份验证。在每个连接中，服务器使用具有公钥的数字证书向客户端验证自身。在RSA加密模式中，服务器通过解密预主密钥以及会话中MAC值的验证来证明其对私钥的所有权。在DH模式中，服务器使用数字签名证明私钥的所有权。如果你到目前为止一直关注这篇博文，应该很容易猜到这是有问题的。</p><h4 id=pkcs1v15>PKCS＃1v1.5<a href=#pkcs1v15 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>Daniel Bleichenbacher致力于识别TLS中RSA的问题。2006年，他设计了针对TLS中使用的RSA签名的pen-and-paper攻击。后来发现包括NSS和OpenSSL在内的主要TLS实现<a href=https://www.ietf.org/mail-archive/web/openpgp/current/msg00999.html>容易受到这种攻击</a>。这些漏洞也与是否正确实现填充有关。前面的这些情况中，RSA签名所用的都是PKCS#1 v1.5填充。在TLS 1.3中，删除了对PKCS#1 v1.5的支持，应用了更新的设计<a href=https://en.wikipedia.org/wiki/Probabilistic_signature_scheme>RSA-PSS</a>。</p><h4 id=签名整个握手记录>签名整个握手记录<a href=#签名整个握手记录 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>我们之前描述过服务器如何使用数字签名来证明密钥交换没有被篡改。在TLS 1.2及更早版本中，服务器的签名仅涵盖部分握手。握手的其他部分，特别是用于协商使用哪个对称密码的部分，不由私钥签名，而使用的是对称MAC来确保握手未被篡改。这种疏忽导致了许多备受瞩目的漏洞（FREAK，LogJam等）。在TLS 1.3中，阻止了这样的做法，因为服务器签名了整个握手记录。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image1.png alt></p><p>FREAK，LogJam和CurveSwap漏洞利用了两件事：</p><ol><li>许多浏览器和服务器仍然支持20世纪90年代出现的弱密码（称为导出密码）；</li><li>用于协商使用哪种密码的握手部分未经数字签名。</li></ol><p>中间人攻击者可以通过让客户端选择服务器端支持的弱密码（或支持的组或支持的曲线）进行密钥交换。然后他们破解了该密钥，完成两条finish messages，让双方都认为他们已经同意通信。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image13.png alt></p><p>这些攻击被称为降级攻击，它们允许攻击者强制两个参与者使用双方支持的最弱密码，即使支持更安全的密码也是如此。在这种攻击方式中，劫持者处于握手的中间，并将从客户端发送给的服务器支持的密码列表更改为仅包含弱导出密码。然后，服务器选择一个弱密码，攻击者通过暴力攻击计算出密钥，允许攻击者在握手时伪造MAC。在TLS 1.3中，这种类型的降级攻击是不可能的，因为服务器现在签名了整个握手，包括密码协商部分。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image14.png alt></p><h3 id=通过简化改善生活>通过简化改善生活<a href=#通过简化改善生活 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>随着除去了上面这些不安全的因素， TLS 1.3 是一个更加优雅和安全的协议。这种改变允许简化协议，使其更容易理解，更快。</p><h4 id=没有更多的外卖菜单>没有更多的外卖菜单<a href=#没有更多的外卖菜单 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>在以前版本的TLS中，主要的协商机制是密码组。密码套件几乎涵盖了可以就连接进行协商的所有内容：</p><ul><li>支持的证书类型</li><li>用于导出键的哈希函数（例如，SHA1，SHA256，&mldr;）</li><li>MAC功能（例如，HMAC与SHA1，SHA256，&mldr;）</li><li>密钥交换算法（例如，RSA，ECDHE，&mldr;&mldr;）</li><li>密码（例如，AES，RC4，&mldr;&mldr;）</li><li>密码模式，如果适用（例如，CBC）</li></ul><p>先前版本的TLS中的密码套已经发展成为巨大的字母组。常用密码套件的示例是：DHE-RC4-MD5或ECDHE-ECDSA-AES-GCM-SHA256。每个密码套件由一个名为Internet Assigned Numbers Authority（IANA）的组织维护的表中的代码点表示。每次引入新密码时，都需要将一组新的组合添加到列表中。这导致代码点的组合爆炸，代表这些参数的每个有效选择。它变得有点乱。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image8.png alt></p><p><img src=https://s.razeen.cn/images/2018/tls13-image16.png alt></p><p>TLS 1.3删除了许多这些遗留功能，允许在三个正交协商之间进行彻底拆分：</p><ul><li>密码+ HKDF哈希</li><li>密钥交换</li><li>签名算法</li></ul><p><img src=https://s.razeen.cn/images/2018/tls13-image6-.png alt></p><p>这种简化的密码套件协商和从根本上减少的一系列协商参开辟了一种新的可能性。这种可能性使得TLS 1.3握手延迟从两次往返降至仅一次往返，从而提供性能提升，确保TLS 1.3受欢迎并广泛采用。</p><h3 id=性能>性能<a href=#性能 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>在TLS1.2中，初次建立连接时，需要两次往返才能开始发送数据。这与服务器和客户端在地理位置上彼此是否靠近没有特别明显关系，但是它在移动网络上却有很大的差异，其中延迟可以高达200ms，这对于人类来说是显而易见的。</p><h3 id=1-rtt模型>1-RTT模型<a href=#1-rtt模型 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>TLS 1.3现在具有更简单的密码协商模型和简化的密钥协商选项（没有RSA，没有用户定义的DH参数）。这意味着每个连接都将使用基于DH的密钥协议，并且服务器支持的参数很容易猜到（ECDHE使用X25519或P-256）正因为这种有限的选择，客户端可以很容易的选择在第一条消息中就发送DH密钥共享参数，而不是等到服务器确认它支持哪些密钥共享。这样，服务器可以获得共享密钥并减少一次往返，提前发送加密数据。例如，Chrome实现的TLS 1.3会在第一条消息中向服务器发送X25519密钥共享。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image3-.png alt></p><p><img src=https://s.razeen.cn/images/2018/tls13-image15.png alt></p><p>在极少数情况下，服务器不支持客户端发送的密钥共享之一，服务器可以发送HelloRetryRequest消息，让客户端知道它支持哪些密钥共享算法。由于列表已被削减太多，预计这种情况不常发生。</p><h3 id=0-rtt恢复>0-RTT恢复<a href=#0-rtt恢复 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>受[QUIC协议的启发，协议得到进一步的优化。它允许客户端将第一条消息中的数据加密后发送到服务器，而且与未加密的HTTP相比，不会产生额外的延迟成本。这是一个重大的改进，一旦TLS 1.3被广泛部署，加密的网络肯定比以前更加快捷。</p><p>在TLS 1.2中，有两种方法可以恢复连接，<a href=https://blog.cloudflare.com/tls-session-resumption-full-speed-and-secure/>会话ID和会话票据</a>。在TLS 1.3中，将这些模式组合起来，形成了预共享密钥（PSK）恢复的新模式。该想法来源于，在建立会话之后，客户端和服务器可以导出称为“恢复主密钥”的共享秘密。该共享秘密可以使用id（会话ID样式）存储在服务器上，也可以通过服务器的密钥（会话票据样式）加密。此会话票据将发送到客户端并在恢复连接时发回。</p><p>对于恢复的连接，双方共享恢复主密钥，因此除了提供前向保密之外，不需要密钥交换。下次客户端连接到服务器时，它可以从上一个会话中获取密码并使用它来加密应用程序数据以及会话票证发送到服务器。</p><h3 id=可重复性>可重复性<a href=#可重复性 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>0-RTT中没有数据交互。它由客户端发送，并由服务器使用，没有任何交互。这对性能很有帮助，但为此也需要付出代价：可重复性。如果攻击者捕获发送到服务器的0-RTT数据包，他们可以重播它，并且服务器有可能认为它是有效。这会产生一些有意思的负面影响。</p><p><img src=https://s.razeen.cn/images/2018/tls13-image12.png alt></p><p>危险重放数据的一个演示就是更改服务器数据的状态。如果将增加计数器，执行数据库事务或执行任何具有永久效果的操作放入0-RTT数据中是有风险的。</p><p>作为客户端，您可以尝试通过仅将“安全”请求放入0-RTT数据来防止这种情况。这里的“安全”表示请求不会更改服务器状态。在HTTP中，不同的方法应该具有不同的语义。HTTP GET请求应该是安全的，因此浏览器通常通过在0-RTT中只发送GET请求来保护HTTPS服务器免受重放攻击。由于大多数页面加载以GET“/”开头，因此页面加载时间更快。</p><p>当在0-RTT中发送的数据用于状态改变请求时，就会发生问题。为帮助防止这种问题，TLS 1.3还包括会话票据中的时间戳。如果这种情况发生太大分歧，客户要么接近光速，要么重放数据。在任何一种情况下，服务器都应该谨慎拒绝0-RTT数据。</p><p>有关0-RTT的更多详细信息以及TLS 1.3中会话恢复的改进，请查看<a href=https://blog.cloudflare.com/introducing-0-rtt/>此前的博客文章</a>。</p><h3 id=可部署性>可部署性<a href=#可部署性 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>TLS 1.3与TLS 1.2及更早版本完全不同，但为了广泛部署，它必须向后兼容现有软件。TLS 1.3从草案到最终发布花了这么长时间的原因之一是，一些现有的软件（即中间键）与新的更改并没有很好地协调。即使在线上对TLS 1.3协议进行一些微小更改（例如消除冗余的ChangeCipherSpec消息，将版本从0x0303提升到0x0304）都会导致某些人的连接问题。</p><p>尽管未来的灵活性已经内置到TLS规范中，但是一些实现对如何处理未来的TLS版本做出了错误的假设。造成这种变化的现象称为<em>骨化</em>，我在前一篇文章中更全面地探讨了<a href=https://blog.cloudflare.com/why-tls-1-3-isnt-in-browsers-yet/>TLS 1.3尚未部署的原因</a>。为了适应这些变化，TLS 1.3被修改为看起来很像TLS 1.2会话恢复（至少在线路上）。这导致了虽然增加了更多功能但不太美观。这是您在线升级最广泛部署的协议之一所付出的代价。</p><h3 id=总结>总结<a href=#总结 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>TLS 1.3是一种现代安全协议，使用<a href=http://tls13tamarin.github.io/TLS13Tamarin/>正式</a> <a href=https://eprint.iacr.org/2016/081>分析</a>等现代工具构建，保持其向后兼容性。它已经过广泛测试，并在使用现实部署数据时进行了迭代。它是一种更清晰，更快速，更安全的协议。<a href=https://blog.cloudflare.com/you-get-tls-1-3-you-get-tls-1-3-everyone-gets-tls-1-3/>所有Cloudflare客户</a>默认启用TLS 1.3 。</p><p>发布TLS 1.3是一项巨大的成就。这是最近最好的一个示例，如何使用已部署长达20年的遗留代码并动态更改它，从而为每个人提供更好的互联网。TLS 1.3在过去三年中一直在争论和分析，现在已准备好迎接黄金时段。欢迎，RFC 8446。</p><ul><li><a href=https://blog.cloudflare.com/rfc-8446-aka-tls-1-3/>原文</a></li></ul></div><div class="related-posts thin"><h2>相关推荐</h2><ul><li><a href=/posts/nginx-tls1.3-draft26/>TLS1.3正式更新，为Nginx添加TLS1.3的支持</a></li><li><a href=/posts/https-githubpages/>GitHub Pages自定义域名开启HTTPS</a></li><li><a href=/posts/what-ct-is-and-how-it-works/>证书透明度是什么？它是怎么工作的？</a></li><li><a href=/posts/ssl-handshake-detail/>HTTPS篇之SSL握手过程详解</a></li></ul></div><hr class=post-end><footer class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://razeencheng.com/tags/%E5%8A%A0%E5%AF%86>加密</a></span><span class=tag><a href=https://razeencheng.com/tags/tls1.3>tls1.3</a></span><span class=tag><a href=https://razeencheng.com/tags/https>https</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>8680 字</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2018-08-20 23:32 +0000</p></footer></article><aside id=toc class=show-toc><div class=toc-title>目录</div><nav id=TableOfContents><ul><li><ul><li><a href=#tls协议的进化>TLS协议的进化</a></li><li><a href=#tls-12已经成为过去>TLS 1.2已经成为过去</a></li><li><a href=#tls-12很慢>TLS 1.2很慢</a></li><li><a href=#定义tls-13>定义TLS 1.3</a></li><li><a href=#一些修复>一些修复</a></li><li><a href=#修复密码>修复密码</a></li><li><a href=#修复数字签名>修复数字签名</a></li><li><a href=#通过简化改善生活>通过简化改善生活</a></li><li><a href=#性能>性能</a></li><li><a href=#1-rtt模型>1-RTT模型</a></li><li><a href=#0-rtt恢复>0-RTT恢复</a></li><li><a href=#可重复性>可重复性</a></li><li><a href=#可部署性>可部署性</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></aside><div class="post-nav thin"><a class=next-post href=https://razeencheng.com/posts/disqus-reactions/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;新</span><br><span>Disqus 添加有趣的 Reactions 的功能</span></a>
<a class=prev-post href=https://razeencheng.com/posts/how-to-use-grpc-in-golang-03/><span class=post-nav-label>旧&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>gRPC在Go中的使用（三）gRPC实现TLS加密通信与流模式</span></a></div><div id=google-ads class=thin><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4450478767591566" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-4450478767591566 data-ad-slot=8164928618 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//razeen-me.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer id=site-footer class="section-inner thin"><p>&copy; 2017 - 2022 <a href=https://razeencheng.com>Razeen</a> &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></p><p>Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://razeencheng.com/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></footer><script src=https://s.razeen.cn/assets/js/mermaid.min.js></script>
<script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerText}</div>`})</script><script src=https://razeencheng.com/js/main.min.4e6345981f1ff315bbb7afa61eacf413923b536e5a4d5b22f698d96b624d48c4.js integrity="sha256-TmNFmB8f8xW7t6+mHqz0E5I7U25aTVsi9pjZa2JNSMQ=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4BKH11NSEY"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4BKH11NSEY")</script></body></html>