<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><meta itemprop=name content="HTTPS篇之SSL握手过程详解"><meta itemprop=description content="​接触HTTPS也有一段时间了，对整个SSL握手的过程零零碎碎的了解了一些，趁着这篇文字系统的总结一下整个SSL握手的过程，结合Wireshark工具让自己更深刻的理解SSL通信过程。"><meta itemprop=datePublished content="2017-12-31T23:59:11+00:00"><meta itemprop=dateModified content="2017-12-31T23:59:11+00:00"><meta itemprop=wordCount content="4412"><meta itemprop=image content="https://razeencheng.com/android-chrome-192x192.png"><meta itemprop=keywords content="https,handshake,"><meta property="og:title" content="HTTPS篇之SSL握手过程详解"><meta property="og:description" content="​接触HTTPS也有一段时间了，对整个SSL握手的过程零零碎碎的了解了一些，趁着这篇文字系统的总结一下整个SSL握手的过程，结合Wireshark工具让自己更深刻的理解SSL通信过程。"><meta property="og:type" content="article"><meta property="og:url" content="https://razeencheng.com/posts/ssl-handshake-detail/"><meta property="og:image" content="https://razeencheng.com/android-chrome-192x192.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-12-31T23:59:11+00:00"><meta property="article:modified_time" content="2017-12-31T23:59:11+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://razeencheng.com/android-chrome-192x192.png"><meta name=twitter:title content="HTTPS篇之SSL握手过程详解"><meta name=twitter:description content="​接触HTTPS也有一段时间了，对整个SSL握手的过程零零碎碎的了解了一些，趁着这篇文字系统的总结一下整个SSL握手的过程，结合Wireshark工具让自己更深刻的理解SSL通信过程。"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon href=/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=mask-icon href=/safari-pinned-tab.svg><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><link rel="shortcut icon" href=/favicon.ico><title>HTTPS篇之SSL握手过程详解</title><link rel=stylesheet href=https://razeencheng.com/css/style.min.a88782436067f84711b02510e9f09bd68bd49c25cd2e03624cd7320fa893b6ea.css integrity="sha256-qIeCQ2Bn+EcRsCUQ6fCb1ovUnCXNLgNiTNcyD6iTtuo=" crossorigin=anonymous></head><body id=page><header id=site-header><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://razeencheng.com>Razeen`s Blog</a></div><nav class="site-nav hide-in-mobile"><a href=https://razeencheng.com/posts/>文章</a>
<a href=https://razeencheng.com/tags/>标签</a>
<a href=https://razeencheng.com/categories/>分类</a>
<a href=https://razeencheng.com/about/>关于</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-social hide-in-mobile"><a href=https://twitter.com/razeencheng target=_blank rel="noopener me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://github.com/razeencheng target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></span><button id=menu-btn class=hdr-btn title=菜单><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://razeencheng.com/posts/>文章</a></li><li><a href=https://razeencheng.com/tags/>标签</a></li><li><a href=https://razeencheng.com/categories/>分类</a></li><li><a href=https://razeencheng.com/about/>关于</a></li></ul></div><main class="site-main section-inner"><article class=thin><header class=post-header><div class=post-meta><span>Dec 31, 2017</span></div><h1>HTTPS篇之SSL握手过程详解</h1></header><div class=content><p>​接触HTTPS也有一段时间了，对整个SSL握手的过程零零碎碎的了解了一些，趁着这篇文字系统的总结一下整个SSL握手的过程，结合Wireshark工具让自己更深刻的理解SSL通信过程。</p><h3 id=什么是握手>什么是握手<a href=#什么是握手 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>​像两个人沟通一样，握手是表示一个会话的开始。对于SSL/TLS来说，通过握手建立连接，交换客户端与服务器之间的信息从而生成会话秘钥(主秘钥)，用来加密之后的消息。</p><p>​在TLS中有两种主要的握手类型：一种基于RSA，一种基于<a href=https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange>Diffie-Hellman</a>。 这两种握手类型的主要区别在于主秘钥交换和认证上。</p><table><thead><tr><th></th><th>秘钥交换</th><th>身份验证</th></tr></thead><tbody><tr><td>RSA握手</td><td>RSA</td><td>RSA</td></tr><tr><td>DH握手</td><td>DH</td><td>RSA/DSA</td></tr></tbody></table><p>​用RSA握手还是DH握手取决于加密套件，后面我们也会带你简单了解加密套件。现在，我们用openssl查看套件时可看到</p><pre tabindex=0><code class=language-cipher data-lang=cipher>➜ openssl ciphers -v
ECDHE-RSA-AES256-GCM-SHA384 	TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(256) Mac=AEAD
ECDHE-ECDSA-AES256-GCM-SHA384 	TLSv1.2 Kx=ECDH     Au=ECDSA Enc=AESGCM(256) Mac=AEAD
AES256-GCM-SHA384               TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD
AES256-SHA256                   TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
...
</code></pre><p>其中kx，au就对应了秘钥交换与身份验证。</p><h3 id=rsa握手>RSA握手<a href=#rsa握手 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>说了这么多终于踏入正题。</p><p>基于RSA的TLS握手整个流程如下如所示。</p><p><img src=https://s.razeen.cn/images/2017/ssl-handshake-rsa.png alt></p><p>通过Wireshark抓包，访问https://www.razeen.me，我们可以看到</p><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_rsa_shake1.png alt></p><p>结合上面两个流程图，我们可以了解整个流程可以分解为:</p><ol><li><p>客户端向服务器发送Client Hello,告诉服务器，我支持的协议版本，加密套件等信息。</p></li><li><p>服务器收到响应，选择双方都支持的协议，套件，向客户端发送Server Hello。同时服务器也将自己的证书发送到客户端(Certificate)。</p></li><li><p>客户端自己生产预主密钥，通过公钥加密预主秘钥，将加密后的预主秘钥发送给服务器 (Client Exchange)。</p></li><li><p>服务器用自己的私钥解密加密的预主密钥。</p></li></ol><p>之后，客户端与服务器用相同的算法根据客户端随机数，服务器随机数，预主秘钥生产主密钥，之后的通信将都用主密钥加密解密。</p><p>下面分别带你一一了解其中细节。</p><h4 id=client--hello>Client Hello<a href=#client--hello class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>​点开Client Hello，我们可以看到客户端向服务器发送了哪些数据。</p><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_rsa_shake_client_hello.png alt></p><p>​在一次新的握手流程中，Client Hello 消息总数第一条消息。这条消息将客户端的功能和首选项告诉服务器。通过抓包数据，通过其字段名我们也很容易理解它的含义。</p><p><strong>Content Type</strong></p><p>​消息的内容类型，告诉服务器，我要握手了。</p><p><strong>Version</strong></p><p>​协议版本（protocol version) 告诉服务器 客户端支持的最佳协议版本。</p><p><strong>Random</strong></p><p>​随机数，也就是流程图中的客户端随机数。包含32字节的数据，其中28字节是随机生成的(Random Bytes)。剩下的4字节包含额外的信息(GMT Unix Time)，受客户端时钟影响（一般浏览器会给他们的时间添加时钟扭曲，或者简单的发送随机4字节）。在握手的时候这随机数都是独一无二的，他们在身份验证中起到举足轻重的作用（可以防止重复攻击，并确认初始数据交换的完整性）。</p><p><strong>Session ID</strong></p><p>​在第一连接时，会话ID(Session ID)字段是空的，这表示客户端告诉服务器 我是新会话，没有其他会话需要恢复。在后续的连接中，这个字段可以保存会话的唯一标识。服务器可以借助会话ID在自己的缓存中找到对应的会话状态。</p><p>​典型的会话ID包含32字节的随机生成的数据，这些数据本身并没有什么价值。</p><p><strong>Cipher Suites</strong></p><p>​密码套件块是由客户端支持的所有密码套件组成的列表，该列表是按优先级顺序排列的。</p><p>​密码套件(cipher suite)是一组选定的加密基元和其他参数，它可以精确定义如何实现安全。套件大致由以下这些属性定义。</p><ul><li>身份验证方法</li><li>密钥交换方法</li><li>加密算法</li><li>加密密钥大小</li><li>密码模式（可应用时）</li><li>MAC算法（可应用时）</li><li>PRF（只有TLS1.2一定使用，其他版本取决于各自协议）</li><li>用于Finished消息的散列函数（TLS1.2）</li><li>verify_data结构的长度（TLS1.2)</li></ul><p>密码套件都倾向于使用较长的描述名称，并且相当一致：它们都是由密钥交换方法、身份验证方法、密码定义以及可选的MAC或PRF算法组合而成，如下图所示：</p><p><img src=https://s.razeen.cn/images/2017/ssl-handshake-ciphers.png alt></p><p><strong>Compression</strong></p><p>​客户端可以提交一个或多个支持的压缩方法。默认是null，代表没有压缩。</p><p><strong>Extensions</strong></p><p>​扩展块由任意数量的扩展组成。这些扩展会携带额外的数据。扩展可以在不修改协议本身的条件下为TLS协议增加功能。如果你想了解更多可以参考<a href=https://tools.ietf.org/html/rfc6066>RFC 6066</a>，这里不多说。</p><h4 id=server-hello>Server Hello<a href=#server-hello class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>​当服务器收到客户端的hello消息的时候，服务器会将服务器选择的参数传送回客户端。这个消息的结构与Client Hello类似，只是每个字段只包含一个选项。</p><p>​服务器不需要支持客户端支持的最佳版本。如果服务器不支持与客户端相同的版本，可以提供某个其他版本以期待客户端能够接受。</p><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_rsa_shake_server_hello.png alt></p><p>如上图所示，服务端选择使用TLS 1.2 (version)，套件使用TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256。</p><h4 id=certificate>Certificate<a href=#certificate class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>​从下图可以看出在服务器发送Server Hello的时候，会同时发送Certificate,Server Hello Done。</p><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_rsa_cert.png alt></p><p><strong>Certificate</strong></p><p>​典型的Certificate消息用于携带X.509证书链。证书链是以ASN.1 DER编码的一系列证书，一个接一个组合而成。叶子证书必须是第一个发送，中间证书按照正确的顺序跟在叶子证书之后。根证书可以并且应该省略掉，因为在这个场景中它没有用处。</p><p>​服务器必须保证它发送的证书与选择的算法套件一致。比方说，公钥算法与套件中使用的必须匹配。除此以外，一些密钥交换算法依赖嵌入证书的特定数据，而且要求证书必须以客户端支持的算法签名。所有这些都表明服务器需要配置多个证书(每个证书可能会配备不同的证书链)。</p><p><strong>Server Hello Done</strong></p><p>​Sever Hello Done 消息表明服务器已经将所有预计的握手消息发送完毕。在此之后，服务器会等待客户端发送消息。</p><h4 id=client-key-exchange>Client Key Exchange<a href=#client-key-exchange class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>​之后客户端向服务器发送Client Key Exchange。最后客户端与服务器互发 Change Cipher Spec，Encrypted Handshake Message。</p><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_rsa_shake_exchange.png alt></p><p><strong>Client Key Exchange</strong></p><p>​Client Key Exchange 消息携带客户端为密钥交换提供的所有信息。从抓包的信息中我们可以看到，秘钥交换的主要内容是RSA Encrypted PreMaster Secret, 也就是利用证书公钥加密后的预主密钥。其中预主密钥(PreMaster Secret)是由客户端生成的48字节的随机数，<a href=https://tools.ietf.org/html/rfc5246#page-58>RFC5426</a>可看到其结构是这样的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>struct <span class=o>{</span>
</span></span><span class=line><span class=cl>	    ProtocolVersion client_version<span class=p>;</span>
</span></span><span class=line><span class=cl>        opaque random<span class=o>[</span>46<span class=o>]</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span> PreMasterSecret<span class=p>;</span>
</span></span></code></pre></div><p><strong>Change Cipher Spec</strong></p><p>​Change Cipher Spec 消息表明发送端已取得用以生成连接参数的足够信息，已生成加密密钥(主密钥)，并且将切换到加密模式。客户端和服务器在条件成熟是会发送这个消息。</p><p>​主密钥的是由预主密钥进一步计算而成，这个过程通过一个伪随机函数(pseudorandom function, PRF)来完成，这个函数可以生产任意数量的伪随机数据。其计算过程如下。</p><pre tabindex=0><code>master_secret = PRF(pre_master_secret,&#34;master secret&#34;,ClientHello.random+ServerHello.random)
</code></pre><h4 id=finishedencrypted-handshake-message>Finished（Encrypted Handshake Message）<a href=#finishedencrypted-handshake-message class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p>​Encrypted Handshake Message 这是由客户端服务器之间协商的算法和密钥保护的第一个消息。它意味着握手已经完成。消息内容将加密，以便双发可以安全地交换验证整个握手完整性所需要的数据。</p><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_rsa_shake_data.png alt></p><p>​这个消息包含verify_data字段，它的值是握手过程中所有消息的散列值。这些消息在连接两端都按照各自所见的顺序排列，并以协商新得到的主密钥计算散列。散列函数与PRF一致，除非协商的套件指定使用其他算法。</p><p>​客户端与服务器的计算方法一致。</p><pre tabindex=0><code>verify_data = PRF(master_secret,finished_label,Hash(handshake_messages))
</code></pre><p>​</p><h3 id=dh握手>DH握手<a href=#dh握手 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>​下图为TLS握手采用DH算法的流程图。与RSA最大的区别在于密钥交换与身份认证上。在RSA中是由客户端发送客户端密钥交换信息完成密钥交换，通过客户端公钥加密，服务端私钥解密完成身份认证。而在DH握手过程中则略有不同。</p><p><img src=https://s.razeen.cn/images/2017/ssl-handshake-dh.png alt></p><p>​下图是我访问https://razeen.me 用Wireshake抓取的数据。</p><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_dh_shake1.png alt></p><p>我们从两个图中可以看出，在DH握手过程中，多了一步Server Key Exchange。Server Key Exchange消息的目的与Client Key Exchange目的相同，都是携带密钥交换的额外数据。而在这里它带的不再是加密的预主密钥了。</p><p>也就是说它的整个流程如下：</p><ol><li><p>客户端向服务器发送Client Hello,告诉服务器，我支持的协议版本，加密套件等信息。</p></li><li><p>a. 服务端收到响应，选择双方都支持的协议，套件，向客户端发送Server Hello。同时服务器也将自己的证书发送到客户端(Certificate)。</p><p>b. 服务器利用私钥将客户端随机数，服务器随机数，服务器DH参数签名，生成服务器签名。</p></li><li><p>服务端向客户端发送服务器DH参数以及服务器签名(Server Key Exchange)。</p></li><li><p>客户端向服务端发送客户端DH参数(Client Key Exchange)。</p></li></ol><p>之后，客户端利用公钥验证服务器签名，客户端与服务器各自利用服务端DH参数、客户端DH参数生成预主密钥，再通过预主密钥、客户端随机数、服务端随机数生成主密钥(会话密钥)。最后握手完成，所有的消息都通过主密钥加密。</p><p>​由于DH握手过程中大部分消息格式与RSA相同，这里不再一一说明。这里主要说明一下DH的密钥交换。</p><h4 id=dh密钥交换>DH密钥交换<a href=#dh密钥交换 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h4><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_dh_shake_exchange.png alt></p><p><img src=https://s.razeen.cn/images/2017/ssl_handshake_dh_shake_exchange2.png alt></p><p>​在DH密钥交换过程中主要需要的参数有6个，其中两个(dh_p和dh_g)成为域参数，由服务器选取。协商过程中，客户端和服务器各自生成另外两个参数，相互发送其中一个参数（dh_Ys和dh_Yc)到对端，经过计算，获得预主共享密钥(PreMasterSecret)，我们可以先看一下DH算法的数学基础。</p><pre tabindex=0><code class=language-dh data-lang=dh>+--------------------------------------------------------------------+
|                    Global Pulic Elements                           |
|                                                                    |
|       dh_p                         prime number                    |
|       dh_g                         prime number, dh_g &lt; dh_p       |
+--------------------------------------------------------------------+
+--------------------------------------------------------------------+
|                    User A Key Generation                           |
|                                                                    |
|       Select private dh_Ys_a       sh_Ys_a &lt; dh_p                  |
|       Calculate public dh_Yc_a     dh_Yc_a = dh_g^dh_Ys_a mod dh_p |
+--------------------------------------------------------------------+
+--------------------------------------------------------------------+
|                    User B Key Generation                           |
|                                                                    |
|       Select private dh_Ys_b       sh_Ys_b &lt; dh_p                  |
|       Calculate public dh_Yc_b     dh_Yc_b = dh_g^dh_Ys_b mod dh_p |
+--------------------------------------------------------------------+
+--------------------------------------------------------------------+
|               Calculation of Secret Key by User A                  |
|                                                                    |
|       Secret Key premaster       premaster = dh_Yc_b^dh_Yc_a mod p |
+--------------------------------------------------------------------+
+--------------------------------------------------------------------+
|               Calculation of Secret Key by User B                  |
|                                                                    |
|       Secret Key premaster       premaster = dh_Yc_a^dh_Yc_b mod p |
+--------------------------------------------------------------------+
</code></pre><p>上面一共出现了 dh_p, dh_g, dh_Ys_a, dh_Yc_a, dh_Ys_a, dh_Yc_a, premaster 共 7 个数，其中：</p><ul><li>公开的数：dh_p, dh_g, dh_Yc_a, dh_Yc_a</li><li>非公开数：dh_Ys_a, dh_Ys_b, premaster</li></ul><p>通常情况下，dg_g 一般为 2 或 5，而 dh_p, dh_Ys_a 和 dh_Ys_b 的取值也非常大，其复杂度至少为 <code>O(dh_p^0.5)</code>。对于攻击者来说，已知 dh_Yc_a，dh_Ys_a 的求解非常困难，同理 dh_Ys_b 的求解也很困难，所以攻击者难以求出 premaster，所以 DH 能够保证通信双方在透明的信道中安全的交换密钥。</p><p>​在上面的介绍中你也知道，如果其中的域参数太弱，将很容易被攻破，正如2015年披露的Logjam攻击表明，512位的DH参数在使用合适的资源情况下可以被攻击者在很短的时间内成功利用。对于这些问题随后有了椭圆曲线的DH秘钥交换(ECDH),ECDH密钥交换发生在一条服务器定义的特殊椭圆曲线上，这条曲线代替了DH中的域参数，从而一定程度上提高了安全性。</p><h3 id=总结>总结<a href=#总结 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>​到这里你理清整个握手过程了么。其实整个过程无非就是在互相交换信息，而基于RSA算法与DH算法的握手最大的区别就在于密钥交换与身份认证。前者利用客户端利用公钥加密预主密钥发送给服务端完成密钥交换，服务端利用私钥解密完成身份认证。后者利用各自发送DH参数完成密钥交换，服务器私钥签名数据，客户端公钥验签完成身份认证。</p><p>​好了就写到这里，文章中如果有错漏之处还请不吝赐教哦~</p><p>​最后，今天也是2018年的第一天，祝大家新年快乐。</p><h3 id=参考资料>参考资料<a href=#参考资料 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p><em>1.</em> HTTPS 权威指南</p><p><em>2.</em><a href=http://blog.syscallx.com/2017/02/21/ssl-perfect-forward-secrecy.html>SSL/TLS Perfect Forward Secrecy</a></p><p><em>3.</em><a href=https://blog.cloudflare.com/keyless-ssl-the-nitty-gritty-technical-details/>Keyless SSL: The Nitty Gritty Technical Details</a></p><p><em>4.</em><a href=https://blog.cloudflare.com/announcing-keyless-ssl-all-the-benefits-of-cloudflare-without-having-to-turn-over-your-private-ssl-keys/>Announcing Keyless SSL™: All the Benefits of CloudFlare Without Having to Turn Over Your Private SSL Keys</a></p></div><hr class=post-end><footer class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://razeencheng.com/tags/https>https</a></span><span class=tag><a href=https://razeencheng.com/tags/handshake>handshake</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>4412 字</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2017-12-31 23:59 +0000</p></footer></article><aside id=toc class=show-toc><div class=toc-title>目录</div><nav id=TableOfContents><ul><li><ul><li><a href=#什么是握手>什么是握手</a></li><li><a href=#rsa握手>RSA握手</a></li><li><a href=#dh握手>DH握手</a></li><li><a href=#总结>总结</a></li><li><a href=#参考资料>参考资料</a></li></ul></li></ul></nav></aside><div class="post-nav thin"><a class=next-post href=https://razeencheng.com/posts/centos-utf-8-warning/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;新</span><br><span>修复远程登陆 Centos 时，出现 UTF-8 Warning</span></a>
<a class=prev-post href=https://razeencheng.com/posts/daily-pg-tips/><span class=post-nav-label>旧&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>Go学习笔记(一) | postgres与golang点点滴滴</span></a></div><div id=google-ads class=thin><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4450478767591566" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-4450478767591566 data-ad-slot=8164928618 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//razeen-me.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer id=site-footer class="section-inner thin"><p>&copy; 2017 - 2022 <a href=https://razeencheng.com>Razeen</a> &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></p><p>Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://razeencheng.com/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></footer><script src=https://s.razeen.cn/assets/js/mermaid.min.js></script>
<script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerText}</div>`})</script><script src=https://razeencheng.com/js/main.min.4e6345981f1ff315bbb7afa61eacf413923b536e5a4d5b22f698d96b624d48c4.js integrity="sha256-TmNFmB8f8xW7t6+mHqz0E5I7U25aTVsi9pjZa2JNSMQ=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4BKH11NSEY"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4BKH11NSEY")</script></body></html>