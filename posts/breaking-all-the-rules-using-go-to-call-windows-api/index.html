<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><meta itemprop=name content="如何用 Go 调用 Windows API"><meta itemprop=description content="在Go中，我们可以很轻松的利用syscall包调用Windows API去做一些更高级/底层的操作。这篇文章，主要记录了我在平时开发过程中以及网上收集到的一些关于Windows API调用相关的知识，或者开发模式，方便你遇到类似的情况后，能更快入手。"><meta itemprop=datePublished content="2019-05-22T22:22:35+00:00"><meta itemprop=dateModified content="2019-05-22T22:22:35+00:00"><meta itemprop=wordCount content="5577"><meta itemprop=image content="https://razeencheng.com/android-chrome-192x192.png"><meta itemprop=keywords content="golang,"><meta property="og:title" content="如何用 Go 调用 Windows API"><meta property="og:description" content="在Go中，我们可以很轻松的利用syscall包调用Windows API去做一些更高级/底层的操作。这篇文章，主要记录了我在平时开发过程中以及网上收集到的一些关于Windows API调用相关的知识，或者开发模式，方便你遇到类似的情况后，能更快入手。"><meta property="og:type" content="article"><meta property="og:url" content="https://razeencheng.com/posts/breaking-all-the-rules-using-go-to-call-windows-api/"><meta property="og:image" content="https://razeencheng.com/android-chrome-192x192.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-22T22:22:35+00:00"><meta property="article:modified_time" content="2019-05-22T22:22:35+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://razeencheng.com/android-chrome-192x192.png"><meta name=twitter:title content="如何用 Go 调用 Windows API"><meta name=twitter:description content="在Go中，我们可以很轻松的利用syscall包调用Windows API去做一些更高级/底层的操作。这篇文章，主要记录了我在平时开发过程中以及网上收集到的一些关于Windows API调用相关的知识，或者开发模式，方便你遇到类似的情况后，能更快入手。"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon href=/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=mask-icon href=/safari-pinned-tab.svg><link rel=manifest crossorigin=use-credentials href=/site.webmanifest><link rel="shortcut icon" href=/favicon.ico><title>如何用 Go 调用 Windows API</title><link rel=stylesheet href=https://razeencheng.com/css/style.min.a88782436067f84711b02510e9f09bd68bd49c25cd2e03624cd7320fa893b6ea.css integrity="sha256-qIeCQ2Bn+EcRsCUQ6fCb1ovUnCXNLgNiTNcyD6iTtuo=" crossorigin=anonymous></head><body id=page><header id=site-header><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://razeencheng.com>Razeen`s Blog</a></div><nav class="site-nav hide-in-mobile"><a href=https://razeencheng.com/posts/>文章</a>
<a href=https://razeencheng.com/tags/>标签</a>
<a href=https://razeencheng.com/categories/>分类</a>
<a href=https://razeencheng.com/about/>关于</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-social hide-in-mobile"><a href=https://twitter.com/razeencheng target=_blank rel="noopener me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://github.com/razeencheng target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></span><button id=menu-btn class=hdr-btn title=菜单><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://razeencheng.com/posts/>文章</a></li><li><a href=https://razeencheng.com/tags/>标签</a></li><li><a href=https://razeencheng.com/categories/>分类</a></li><li><a href=https://razeencheng.com/about/>关于</a></li></ul></div><main class="site-main section-inner"><article class=thin><header class=post-header><div class=post-meta><span>May 22, 2019</span></div><h1>如何用 Go 调用 Windows API</h1></header><div class=content><p>有时候为了更好的兼容Windows, 或者我们为了获得更高级别功能的访问权限（如配置或创建JobObjects或安全令牌等），我们需要直接去调用Windows的系统API。 很幸运，我们可以利用<code>syscall</code>包与系统直接通信，不用用到<code>CGO</code> 。 然而，也有不方便的地方，如大多数的API，我们需要依赖不安全 <code>(unsafe)</code>的内存管理。</p><p>这篇文章，主要记录了我在平时开发过程中以及网上收集到的一些关于Windows API调用相关的知识，或者开发模式，方便你遇到类似的情况后，能更快入手。</p><blockquote><p>注 1 本文完整Demo在<a href=https://github.com/razeencheng/demo-go/tree/master/windows_api>这里</a>。
注2 文章中并未严格区分过程与函数。</p></blockquote><h3 id=关于syscall-包>关于<code>syscall</code> 包<a href=#关于syscall-包 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>在Go中，<code>syscall</code>包会由于你指定的系统或架构的不同而编译出不同的结果，因为<code>syscall</code>包里需要编译的函数或类型会根据你指定的编译参数不同而不同。在导入<code>syscall</code>时你必须在代码中指定"build tags" 或 用指定的文件后缀来命名你的文件。 Dave Cheney <a href=https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool>有篇文章</a>深入的介绍了<code>go build</code>机制，可以看一看。简单来说，</p><ul><li>如果你的文件命名结构是这样的，<code>name_{GOOS}_{GOARCH}.go</code> 或者 <code>name_{GOOS}.go</code>, 那么这个文件只有在指定的<code>GOOS</code>+指定的<code>GOARCH</code>上才会编译。如：<code>myfile_windows_amd64.go</code>只会在<code>amd64</code>架构CPU的Windows上才会编译。 而<code>myfile_windows.go</code>会在Windows上编译，就不限制CPU架构了。</li><li>如果你在go代码顶部增加<code>// +build windows,amd64</code> 注释，那么该文件只会在<code>amd64</code>架构CPU的Windows上才会编译。</li></ul><h3 id=关于-unsafe包>关于 <code>unsafe</code>包<a href=#关于-unsafe包 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>下面是一段<code>Youtube</code>视频(需要代理)。</p><p>视频中 <code>Rob Pike</code>提到：</p><p><em>With the unsafe package there are no guarantees.</em></p><p>是的，<code>Rob Pike</code>不推荐使用<code>unsafe</code>包，因为它<strong>没有任何保障</strong>。</p><p>那么，为什么说使用<code>unsafe</code>包没有任何保障呢？</p><ol><li><p>Go (运行时) 不能保证内置类型（如切片、字符串）在不同的Go版本中内存结构是完全一样的。而且作为支持垃圾回收的语言，开发者并不知道Go内存管理的细节。<code>unsafe</code>包会暴露一些内部实现或实际的内存地址，这可能会让你做一些超出预期的事情，如你不小心改变了某个指针指向的地址。</p></li><li><p>Go (语言层面) 不能保证不同版本之间会有相同的特征或者函数签名，换句话来说，就是在 <a href=https://golang.org/doc/go1compat>Go 1.x的兼容性承诺</a>中,并不包含<code>unsafe</code>包。</p></li></ol><blockquote><p><strong>Warning:</strong> <em>Avoid <code>unsafe</code> like the plague; if you can help it.</em></p></blockquote><p>这两点都告诉我们，在使用<code>unsafe</code>包的时候，我们需要特别的注意应该怎么去使用。我们必须了解，用<code>unsafe</code>包操作内存时，我们能做什么和不能做什么。而且这也可能会因为不同的Go版本而发生变化，在<code>unsafe</code>的<a href=https://golang.org/pkg/unsafe/>官方文档</a>中，我们能了解到哪些我们该做，哪些不该做，我们应该密切关注。</p><p><strong>Note:</strong> 从技术上来说，<code>syscall</code>包，也不在 <a href=https://golang.org/doc/go1compat>Go 1.x的兼容性承诺</a>中，因为它也不能保证系统是否向后兼容。不过，从Go1.4开始, go底层基本稳定，只有在操作系统发生变化才会有可能发生更改。而调用<code>Windows DLL</code>的部分改变的可能性比较小，这点对我们是个好消息。</p><p>在<a href=https://godoc.org/golang.org/x/sys/windows><code>x/sys/windows</code></a>包中，包含了Go1.x中使用的所有的Windows API调用，你可以直接拿来使用，但注意以下几点：</p><ol><li>该包不在<a href=https://golang.org/doc/go1compat>Go 1.x的兼容性承诺</a>中, 不能保证你的代码稳定，如果想保持稳定，可以切到稳定的Git版本中。</li><li>该包的目标也不是暴露所有的Windows API, 而是为Go标准库其他包提供更便携的接口，如<code>os</code>,<code>time</code>和<code>net</code>包。所以你需要的内容，不一定能在该包找到。</li></ol><p>虽然是这样，但是现在我们知道了该用那些包去调用Windows API了，同时我们也要知道这会有一定的风险。</p><h3 id=windows-api>Windows API<a href=#windows-api class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>Microsoft 提供了大部分的<a href=https://docs.microsoft.com/en-us/windows/desktop/apiindex/api-index-portal>Windows API</a>文档。API是通过Windows安装时的<a href=%5Bhttps://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%5D(https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93)>DLL(Dynamic Link Library)</a>发布的。DLL是否可用取决于Windows的版本，但API文档中都会列出API什么时候启用，过时或废弃。</p><h3 id=加载dll>加载DLL<a href=#加载dll class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>要在Go中加载DLL，可以使用<code>syscall.NewLazyDLL</code>或<code>syscall.LoadLibrary</code> 。</p><ul><li><p><code>NewLazyDLL</code>返回一个<code>*LazyDLL</code>，懒加载，只在第一次调用其函数时才加载库;</p></li><li><p><code>LoadLibrary</code>是立即加载DLL库。</p></li></ul><p>其实在<code>golang.org/x/sys/windows</code>还支持<code>windows.NewLazySystemDLL</code>的方式加载。这是一种安全的加载方式，它能确保DLL搜索路径被绑定到了Windows系统目录。</p><h3 id=创建函数>创建函数<a href=#创建函数 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>当我们加载（懒加载）了DLL库过，我们就要使用<code>dll.NewProc("ProcName")</code>去引用一些DLL中的函数(过程)。如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span><span class=err>（</span>
</span></span><span class=line><span class=cl>    <span class=nx>kernel32DLL</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>NewLazyDLL</span><span class=err>（“</span><span class=nx>kernel32</span><span class=p>.</span><span class=nx>dll</span><span class=err>”）</span>
</span></span><span class=line><span class=cl>    <span class=nx>procOpenProcess</span> <span class=p>=</span> <span class=nx>kernel32DLL</span><span class=p>.</span><span class=nx>NewProc</span><span class=err>（“</span><span class=nx>OpenProcess</span><span class=err>”）</span>
</span></span><span class=line><span class=cl><span class=err>）</span>
</span></span></code></pre></div><p>一旦有个这些引用，我们就可以<code>Call</code>这个函数本身的方法，或者使用<code>syscall.Syscall</code>函数及其变体进行API调用。使用的过程中发现<code>Call</code>方法更方便，但<code>syscall.Syscall</code>性能更优。根据函数参数的多数，我们可以使用</p><p><code>syscall.Syscall</code>的变体。</p><ul><li><code>syscall.Syscall</code> ：少于4个参数</li><li><code>syscall.Syscall6</code>：4到6个参数</li><li><code>syscall.Syscall9</code>：7到9个参数</li><li><code>syscall.Syscall12</code>：10到12个参数</li><li><code>syscall.Syscall15</code>：13到15个参数</li></ul><p>目前Go v1.12中，无法调用超过15个参数的函数。虽然我从来没有遇到过，但在<a href=https://github.com/golang/go/issues/28434>于OpenGL中</a>确实有这种情况。</p><h3 id=api函数签名>API函数签名<a href=#api函数签名 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>在实际调用DLL函数之前，我们必须要了解一下过程所需要的参数，类型，大小。Microsoft将此描述为Windows API文档的一部分。如<code>CreateJobObjectA</code>的过程签名如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>HANDLE</span> <span class=nf>CreateJobObjectA</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>LPSECURITY_ATTRIBUTES</span> <span class=n>lpJobAttributes</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>LPCSTR</span>                <span class=n>lpName</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>也就是说，<code>CreateJobObjectA</code>需要一个指向<code>LPSECURITY_ATTRIBUTES</code>结构的指针，和一个指向C-String的指针（ASCII编码，技术上是<a href=https://en.wikipedia.org/wiki/Windows-1252>Windows-1252编码</a> ;它与ASCII兼容）。</p><h3 id=c结构与go结构>C结构与Go结构<a href=#c结构与go结构 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>在文档中我们可以搜索到，<code>LPSECURITY_ATTRIBUTES</code>是这么定义的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_SECURITY_ATTRIBUTES</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>nLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>LPVOID</span> <span class=n>lpSecurityDescriptor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>BOOL</span>   <span class=n>bInheritHandle</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>SECURITY_ATTRIBUTES</span><span class=p>,</span> <span class=o>*</span><span class=n>PSECURITY_ATTRIBUTES</span><span class=p>,</span> <span class=o>*</span><span class=n>LPSECURITY_ATTRIBUTES</span><span class=p>;</span>
</span></span></code></pre></div><p>这时，我们就必须构造一个类似的Go结构来替代它。这时我们可以参考<code>syscall</code>中<a href=https://godoc.org/golang.org/x/sys/windows#SecurityAttributes>SecurityAttributes</a>的定义。</p><p>在Windows API中，我们可以看到，<code>SecurityAttributes</code>是这么定义的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_SECURITY_ATTRIBUTES</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>  <span class=n>nLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>LPVOID</span> <span class=n>lpSecurityDescriptor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>BOOL</span>   <span class=n>bInheritHandle</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>SECURITY_ATTRIBUTES</span><span class=p>,</span> <span class=o>*</span><span class=n>PSECURITY_ATTRIBUTES</span><span class=p>,</span> <span class=o>*</span><span class=n>LPSECURITY_ATTRIBUTES</span><span class=p>;</span>
</span></span></code></pre></div><p>而Go中<a href=https://godoc.org/golang.org/x/sys/windows#SecurityAttributes>SecurityAttributes</a>的定义为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>SecurityAttributes</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>Length</span>             <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>    <span class=nx>SecurityDescriptor</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>    <span class=nx>InheritHandle</span>      <span class=kt>uint32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由此我们大概知道， <code>DWORD</code>对应Go <code>uint32</code>， <code>LPVOID (* void)</code>对应<code>uintptr</code>，<code>BOOL</code>对应<code>uint32</code>。所以在你不知道用什么类型来表示C中对应的结构时，你可以去看看<code>syscall</code>或<code>go.sys</code>库中找找，或许能有收获。Windows一些参考类型<a href=https://docs.microsoft.com/en-us/windows/desktop/WinProg/windows-data-types>这里</a>也有描述。</p><p>然而，了解下面这些常见C类型与Go类型的对应关系会非常有用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>BOOL</span>          <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>BOOLEAN</span>       <span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>BYTE</span>          <span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>DWORD</span>         <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>DWORD64</span>       <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>	<span class=nx>HANDLE</span>        <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>HLOCAL</span>        <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>LARGE_INTEGER</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>	<span class=nx>LONG</span>          <span class=kt>int32</span>
</span></span><span class=line><span class=cl>	<span class=nx>LPVOID</span>        <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>SIZE_T</span>        <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>UINT</span>          <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>ULONG_PTR</span>     <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>ULONGLONG</span>     <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>	<span class=nx>WORD</span>          <span class=kt>uint16</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><h3 id=字符串>字符串<a href=#字符串 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>在Windows中，一些函数使用的字符串有两种类型：一种是ANSI编码的，一种是UTF-16编码的。</p><p>如<code>CreateProcess</code>函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>kernel32DLL</span> <span class=o>=</span> <span class=n>syscall</span><span class=p>.</span><span class=n>NewLazyDLL</span><span class=p>(</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>procCreateProcessA</span> <span class=o>=</span> <span class=n>kernel32DLL</span><span class=p>.</span><span class=n>NewProc</span><span class=p>(</span><span class=s>&#34;CreateProcessA&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>procCreateProcessW</span> <span class=o>=</span> <span class=n>kernel32DLL</span><span class=p>.</span><span class=n>NewProc</span><span class=p>(</span><span class=s>&#34;CreateProcessW&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>不管是哪一种，我们都不能直接使用Go中的字符串。这就需要我们去做一些兼容。其实这很简单，只要我们在原始字符串后面加上一个零值即可。如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;unicode/utf16&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// StringToCharPtr converts a Go string into pointer to a null-terminated cstring.
</span></span></span><span class=line><span class=cl><span class=c1>// This assumes the go string is already ANSI encoded.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>StringToCharPtr</span><span class=p>(</span><span class=nx>str</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=kt>uint8</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>chars</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>str</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>// null terminated
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>chars</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// StringToUTF16Ptr converts a Go string into a pointer to a null-terminated UTF-16 wide string.
</span></span></span><span class=line><span class=cl><span class=c1>// This assumes str is of a UTF-8 compatible encoding so that it can be re-encoded as UTF-16.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>StringToUTF16Ptr</span><span class=p>(</span><span class=nx>str</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=kt>uint16</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>wchars</span> <span class=o>:=</span> <span class=nx>utf16</span><span class=p>.</span><span class=nf>Encode</span><span class=p>([]</span><span class=nb>rune</span><span class=p>(</span><span class=nx>str</span> <span class=o>+</span> <span class=s>&#34;\x00&#34;</span><span class=p>))</span>	
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>wchars</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中<code>StringToUTF16Ptr</code>在标准库<code>syscall</code>中已经有了。</p><h3 id=调用api>调用API<a href=#调用api class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>把上面这些知识都用到，我们就可以开始调用一些API了。如我们调用<code>CreateJobObjectW</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=nx>kernel32DLL</span>          <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>NewLazyDLL</span><span class=p>(</span><span class=s>&#34;kernel32.dll&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>procCreateJobObjectW</span> <span class=p>=</span> <span class=nx>kernel32DLL</span><span class=p>.</span><span class=nf>NewProc</span><span class=p>(</span><span class=s>&#34;CreateJobObjectW&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// CreateJobObject uses the CreateJobObjectW Windows API Call to create and return a Handle to a new JobObject
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>CreateJobObject</span><span class=p>(</span><span class=nx>attr</span> <span class=o>*</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>SecurityAttributes</span><span class=p>,</span> <span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>Handle</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>r1</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>procCreateJobObjectW</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=nb>uintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>attr</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>		<span class=nb>uintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>syscall</span><span class=p>.</span><span class=nf>StringToUTF16Ptr</span><span class=p>(</span><span class=nx>name</span><span class=p>))),</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>Errno</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span><span class=nx>r1</span><span class=p>),</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>不管调用哪个API，<code>Call</code>的模式都是一样的。</p><p>而且<code>syscall.Syscall</code>函数始终返回<code>r1,r2 uintptr,err error</code>， 就最近的实践(windows_amd64)来看，基本可以确定:</p><ul><li><p>r1 始终返回 <code>syscall</code>的值；</p></li><li><p>r2 暂且使用；</p></li><li><p>err 返回调用Windows API<code>GetLastError</code>的结果，这是<code>syscall</code>自动调用的。</p></li></ul><p>而你传入<code>Call</code>中的值必须全部是<code>uintptr</code>，不管你原来的类型是什么。但，Go的指针很特别。</p><p>由于Go支持垃圾回收，标准的Go指针不是直接指向了物理内存中的一个地址。Go在运行时可以轻松的修改Go指针指向的物理内存地址，如增加堆栈时。当我们把一个Go指针通过<code>unsafe.Pointer</code>转换成<code>uintptr</code>时，对Go运行时来说，该指针变成了一个未被Go运行时追踪对一个数字而已。即使在下一个指令内，我们也无法确定这个数字指向的是否是它原来指向的那块有效的内存！</p><p>正因为如此，我们必须在Syscalls调用时，将指针指向确定的内存。使用<code>uintptr(unsafe.Pointer(&x))</code>构造一个参数，告诉编译器，在Syscall期间不能修改x的内存空间。这样，C函数就能正常的去处理该指针了，直到Syscall返回为止。</p><p>在<a href=https://golang.org/pkg/unsafe/#Pointer>godoc for unsafe.Pointer中</a>中写明了四种<code>unsafe.Pointers</code>的操作方式原则。这里用到</p><blockquote><p>(4) Conversion of a Pointer to a uintptr when calling syscall.Syscall.</p></blockquote><h3 id=获取原始数据>获取原始数据<a href=#获取原始数据 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>有时，Syscall会自动为你填充C结构的内存块，如果你要使用就必须将其转化为可用的类型。</p><p>许多API的一般调用模式如下：</p><ol><li><p>通过空缓冲区调用一次API，指定一个获取缓冲区长度的变量，获取缓冲区的实际大小；</p></li><li><p>API返回<code>ERROR_INSUFFICIENT_LENGTH</code>错误，同时将长度值更新为实际需要的长度；</p></li><li><p>指定一个实际长度的扩展缓冲区，重新调用；</p></li><li><p>调用成功。</p></li></ol><p>如，我们需要调用<code>GetExtendedTcpTable</code>函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>IPHLPAPI_DLL_LINKAGE</span> <span class=n>DWORD</span> <span class=nf>GetExtendedTcpTable</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>PVOID</span>           <span class=n>pTcpTable</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>PDWORD</span>          <span class=n>pdwSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>BOOL</span>            <span class=n>bOrder</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>ULONG</span>           <span class=n>ulAf</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>TCP_TABLE_CLASS</span> <span class=n>TableClass</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>ULONG</span>           <span class=n>Reserved</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p><code>GetExtendedTcpTable</code>返回的数据为<code>pTcpTable</code> 和 <code>pdwSize</code> ， 思路如下:</p><ol><li>我们第一次将<code>pTcpTable</code>直接指一个0值，使用<code>dwSize</code>来获取<code>pTcpTable</code>的实际长度；</li><li>这时，会返回错误<code>ERROR_INSUFFICIENT_BUFFER</code>, 同时<code>dwSize</code>的值被设置成了<code>pTcpTable</code>的实际大小；</li><li>指定一个<code>dwSize</code>大小的<code>[]byte</code>接收数据；</li><li>成功。</li></ol><p>部分代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=nx>iphlpapiDLL</span>             <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>NewLazyDLL</span><span class=p>(</span><span class=s>&#34;iphlpapi.dll&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>procGetExtendedTcpTable</span> <span class=p>=</span> <span class=nx>iphlpapiDLL</span><span class=p>.</span><span class=nf>NewProc</span><span class=p>(</span><span class=s>&#34;GetExtendedTcpTable&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// GetExtendedTcpTable function retrieves a table that contains a list of TCP endpoints available to the application.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>GetExtendedTcpTable</span><span class=p>(</span><span class=nx>order</span><span class=p>,</span> <span class=nx>ulAf</span><span class=p>,</span> <span class=nx>tableClass</span> <span class=kt>uint32</span><span class=p>)</span> <span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>dwSize</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>ret</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>procGetExtendedTcpTable</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=mi>0</span><span class=p>,</span>                                <span class=c1>// PVOID
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nb>uintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>dwSize</span><span class=p>)),</span> <span class=c1>// PDWORD
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nb>uintptr</span><span class=p>(</span><span class=nx>order</span><span class=p>),</span>                   <span class=c1>// BOOL
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nb>uintptr</span><span class=p>(</span><span class=nx>ulAf</span><span class=p>),</span>                    <span class=c1>// ULONG
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nb>uintptr</span><span class=p>(</span><span class=nx>tableClass</span><span class=p>),</span>              <span class=c1>// TCP_TABLE_CLASS
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=mi>0</span><span class=p>,</span>                                <span class=c1>// ULONG
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>ret</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;get extended tcp table size failed code %x&#34;</span><span class=p>,</span> <span class=nx>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>syscall</span><span class=p>.</span><span class=nf>Errno</span><span class=p>(</span><span class=nx>ret</span><span class=p>)</span> <span class=o>==</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>ERROR_INSUFFICIENT_BUFFER</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>buffer</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>dwSize</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>ret</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>procGetExtendedTcpTable</span><span class=p>.</span><span class=nf>Call</span><span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=nb>uintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>buffer</span><span class=p>[</span><span class=mi>0</span><span class=p>])),</span>
</span></span><span class=line><span class=cl>			<span class=nb>uintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>dwSize</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>			<span class=nb>uintptr</span><span class=p>(</span><span class=nx>order</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=nb>uintptr</span><span class=p>(</span><span class=nx>ulAf</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=nb>uintptr</span><span class=p>(</span><span class=nx>tableClass</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=nb>uintptr</span><span class=p>(</span><span class=nb>uint32</span><span class=p>(</span><span class=mi>0</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>		<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>ret</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;get extended tcp table failed code %x&#34;</span><span class=p>,</span> <span class=nx>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>buffer</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>errors</span><span class=p>.</span><span class=nf>Wrapf</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=s>&#34;get extended tcp table size failed code %x&#34;</span><span class=p>,</span> <span class=nx>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果你看过<a href=https://docs.microsoft.com/en-us/windows/desktop/api/iphlpapi/nf-iphlpapi-getextendedtcptable>上面函数的API</a>，你应该会知道输入参数<code>ulAf</code>和<code>TableClass</code>的值 决定了输出的buffer具体的内容。</p><p>如果我们输入的是<code>AF_INET + TCP_TABLE_OWNER_PID_ALL</code> 那么我们得到的数据的实际结构应该是<a href=https://docs.microsoft.com/en-us/windows/desktop/api/tcpmib/ns-tcpmib-_mib_tcptable_owner_pid><code>MIB_TCPTABLE_OWNER_PID</code></a>，其结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>_MIB_TCPTABLE_OWNER_PID</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>DWORD</span>                <span class=n>dwNumEntries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>MIB_TCPROW_OWNER_PID</span> <span class=n>table</span><span class=p>[</span><span class=n>ANY_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>MIB_TCPTABLE_OWNER_PID</span><span class=p>,</span> <span class=o>*</span><span class=n>PMIB_TCPTABLE_OWNER_PID</span><span class=p>;</span>
</span></span></code></pre></div><p>这里第一个参数<code>dwNumEntries</code>指明有<code>MIB_TCPROW_OWNER_PID</code> table的数量。</p><p>而第二个参数则是一个变长的数组。。。 那么我们该怎么用Go去表示呢？</p><h3 id=处理变长数据>处理变长数据<a href=#处理变长数据 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>其实我们可以利用数组来创建一个兼容该结构的Go结构，这要得益于Go中数组的内存布局为连续的内存区域。</p><p>我们定义的对应结构如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MIB_TCPTABLE_OWNER_PID</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>dwNumEntries</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>table</span>        <span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=nx>MIB_TCPROW_OWNER_PID</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MIB_TCPROW_OWNER_PID</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>dwState</span>      <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>dwLocalAddr</span>  <span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>dwLocalPort</span>  <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>dwRemoteAddr</span> <span class=p>[</span><span class=mi>4</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=nx>dwRemotePort</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>dwOwningPid</span>  <span class=kt>uint32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>你会说，怎么<code>table</code>的长度只为1，这里先存个疑问。</p><p>现在我们首先要知道<code>dwNumEntries</code>的大小，我们才能确定table的数量。于是利用<code>unsafe.Pointer</code>将buffer内的数据转换为Go结构。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>pTable</span> <span class=o>:=</span> <span class=p>(</span><span class=o>*</span><span class=nx>MIB_TCPTABLE_OWNER_PID</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>buffer</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</span></span></code></pre></div><p>这里，我们将一个指针指向缓冲区的第一个字节的内存地址，然后利用<code>unsafe.Pointer</code>我们可以将该指针转换为任意类型的指针。其实这个操作是非常危险的，如果你不知道为什么要转换的话。这里我们能转化是因为我们遵循<code>unsafe.Pointer</code><a href=https://golang.org/pkg/unsafe/>文档中的第一条</a>：</p><blockquote><p>(1) Conversion of a *T1 to Pointer to *T2.</p><p>Provided that T2 is no larger than T1 and that the two share an equivalent memory layout, this conversion allows reinterpreting data of one type as data of another type.</p></blockquote><p>也就是说，要把*T1转换为*T2，那么T2的长度必须比T1的长，而且T1,T2的内存布局必须相同。</p><p>那么，刚刚我们把table 的类型指定为<code>[1]MIB_TCPROW_OWNER_PID</code>, 长度为1显然不是正确的大小。但这没关系，因为<code>[1]MIB_TCPROW_OWNER_PID</code>的长度肯定是小于实际<code>[1+N]MIB_TCPROW_OWNER_PID</code>的长度的。而且他们的内存布局是一样的。</p><p>由于此时，我们已经知道了<code>dwNumEntries</code>的大小，我们可以使用<code>unsafe.Pointer</code>的另一规则来遍历获取数组。</p><blockquote><p>(3) Conversion of a Pointer to a uintptr and back, with arithmetic.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>rows</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>MIB_TCPROW_OWNER_PID</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=nx>pTable</span><span class=p>.</span><span class=nx>dwNumEntries</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>int</span><span class=p>(</span><span class=nx>pTable</span><span class=p>.</span><span class=nx>dwNumEntries</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>rows</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>MIB_TCPROW_OWNER_PID</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>			<span class=nb>uintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pTable</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>				<span class=nb>uintptr</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span><span class=o>*</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>pTable</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=mi>0</span><span class=p>])))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><p>在这里，我们利用<code>规则 (3)</code>迭代已知长度的数组，因为我们知道第一个元素的位置，每个元素的大小，元素的个数，以及结构在内存中的布局是连续的。</p><p>这里还有一个更简单的方法，能让我们直接获取table的数据:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=nx>rows2</span> <span class=o>:=</span> <span class=p>((</span><span class=o>*</span><span class=p>[</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>30</span><span class=p>]</span><span class=nx>MIB_TCPROW_OWNER_PID</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pTable</span><span class=p>.</span><span class=nx>table</span><span class=p>[</span><span class=mi>0</span><span class=p>]))[:</span><span class=nb>int</span><span class=p>(</span><span class=nx>pTable</span><span class=p>.</span><span class=nx>dwNumEntries</span><span class=p>):</span><span class=nb>int</span><span class=p>(</span><span class=nx>pTable</span><span class=p>.</span><span class=nx>dwNumEntries</span><span class=p>)])</span>
</span></span></code></pre></div><p>这种做法一开始就将这个指针转换成一个非常大的数组指针，然后使用正确的长度取获取实际的内容。好处是不用创建其他切片，复制数据；缺点就是我们需要分配一个足够大的内存去接收，这个大小各平台会有一些差异。</p><p>你可以在这里体验一下<a href=https://play.golang.org/p/1XN1bLer-se>Go Playground</a>。</p><h3 id=最后>最后<a href=#最后 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h3><p>现在你应该知道了调用Windows API的一些基本步骤与方法，如果遇到问题可以留言，我们一起解决～</p><ul><li>原文<a href=https://medium.com/jettech/breaking-all-the-rules-using-go-to-call-windows-api-2cbfd8c79724>Breaking all the rules: Using Go to call Windows API</a> 有所改动。</li></ul></div><div class="related-posts thin"><h2>相关推荐</h2><ul><li><a href=/posts/oauth2-protocol-details/>Go学习笔记(七) | 理解OAuth 2.0并实现一个客户端</a></li><li><a href=/posts/go-swagger/>Go学习笔记(六) | 使用swaggo自动生成Restful API文档</a></li><li><a href=/posts/go-snippets/>Go学习笔记(五) | 使用代码片段(snippets)提高编码效率</a></li><li><a href=/posts/how-to-use-grpc-in-golang-03/>gRPC在Go中的使用（三）gRPC实现TLS加密通信与流模式</a></li><li><a href=/posts/how-to-use-grpc-in-golang-02/>gRPC在Go中的使用（二）gRPC实现简单通讯</a></li></ul></div><hr class=post-end><footer class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://razeencheng.com/tags/golang>golang</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>5577 字</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2019-05-22 22:22 +0000</p></footer></article><aside id=toc class=show-toc><div class=toc-title>目录</div><nav id=TableOfContents><ul><li><ul><li><a href=#关于syscall-包>关于<code>syscall</code> 包</a></li><li><a href=#关于-unsafe包>关于 <code>unsafe</code>包</a></li><li><a href=#windows-api>Windows API</a></li><li><a href=#加载dll>加载DLL</a></li><li><a href=#创建函数>创建函数</a></li><li><a href=#api函数签名>API函数签名</a></li><li><a href=#c结构与go结构>C结构与Go结构</a></li><li><a href=#字符串>字符串</a></li><li><a href=#调用api>调用API</a></li><li><a href=#获取原始数据>获取原始数据</a></li><li><a href=#处理变长数据>处理变长数据</a></li><li><a href=#最后>最后</a></li></ul></li></ul></nav></aside><div class="post-nav thin"><a class=next-post href=https://razeencheng.com/posts/simple-use-go-exec-command/><span class=post-nav-label><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg>&nbsp;新</span><br><span>Go学习笔记(八) | 使用 os/exec 执行命令</span></a>
<a class=prev-post href=https://razeencheng.com/posts/auto-change-network-location-base-on-name-of-wifi/><span class=post-nav-label>旧&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></span><br><span>Mac OS 自动根据 WI-FI 名字改变网络位置</span></a></div><div id=google-ads class=thin><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4450478767591566" crossorigin=anonymous></script>
<ins class=adsbygoogle style=display:block data-ad-client=ca-pub-4450478767591566 data-ad-slot=8164928618 data-ad-format=auto data-full-width-responsive=true></ins>
<script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div id=comments class=thin><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//razeen-me.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></main><footer id=site-footer class="section-inner thin"><p>&copy; 2017 - 2022 <a href=https://razeencheng.com>Razeen</a> &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></p><p>Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://razeencheng.com/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></footer><script src=https://s.razeen.cn/assets/js/mermaid.min.js></script>
<script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerText}</div>`})</script><script src=https://razeencheng.com/js/main.min.4e6345981f1ff315bbb7afa61eacf413923b536e5a4d5b22f698d96b624d48c4.js integrity="sha256-TmNFmB8f8xW7t6+mHqz0E5I7U25aTVsi9pjZa2JNSMQ=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4BKH11NSEY"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4BKH11NSEY")</script></body></html>